6502 ASSEMBLY LANGUAGE BEGINNER’S MANUAL

Introduction

The 6502 CPU is an 8-bit microprocessor. Registers:
- A: accumulator, used for math and logic
- X: X index register, used for loops and offsets
- Y: Y index register, used for offsets
- PC: 16-bit program counter
- SP: 8-bit stack pointer, stack at 0x0100–0x01FF
- P: processor status (flags: N, V, ignored, B, D, I, Z, C)

Memory: 0x0000–0xFFFF
- Zero page: 0x0000–0x00FF (faster access)
- Stack: 0x0100–0x01FF
Programs usually loaded at $0200 or $8000. Hardware registers may be memory-mapped.

Addressing Modes

- Immediate: #<value>, operand is constant. Example: LDA #$10
- Absolute: $<addr>, full 16-bit address. Example: LDA $1234
- Absolute,X: $<addr>,X adds X to address. LDA $1000,X
- Absolute,Y: $<addr>,Y adds Y to address. LDA $1000,Y
- Zero Page: $<byte>, address 0x00–0xFF. LDA $12
- Zero Page,X: $<byte>,X adds X, wraps at 0xFF. LDA $12,X
- Zero Page,Y: $<byte>,Y adds Y, wraps at 0xFF. LDY $12,Y
- Indirect: ($<addr>), only for JMP. JMP ($1234)
- Indexed Indirect (X): (<byte>,X). LDA ($10,X)
- Indirect Indexed (Y): (<byte>),Y. LDA ($10),Y
- Relative: REL, 8-bit signed offset, for branches only.
- Accumulator: A. Instruction operates on A. ASL A
- Implied: IMP, no operand. Example: CLC

Instructions

Load and Store

- LDA: loads A. Modes: #, $, $X, $Y, 0x, 0xX, (X), (Y)
- LDX: loads X. Modes: #, $, 0x, 0xY
- LDY: loads Y. Modes: #, $, 0x, 0xX
- STA: stores A. Modes: $, $X, $Y, 0x, 0xX, (X), (Y)
- STX: stores X. Modes: $, 0x, 0xY
- STY: stores Y. Modes: $, 0x, 0xX

Arithmetic and Logic

- ADC: add with carry. A = A + M + C. Flags N, V, Z, C
- SBC: subtract with carry. A = A - M - (1-C)
- INC: increment memory
- INX: increment X
- INY: increment Y
- DEC: decrement memory
- DEX: decrement X
- DEY: decrement Y
- AND: bitwise AND with A
- ORA: bitwise OR with A
- EOR: bitwise XOR with A
- CMP: compare A with memory
- CPX: compare X with memory
- CPY: compare Y with memory

Shifts and Rotates

- ASL: arithmetic shift left (A or memory)
- LSR: logical shift right (A or memory)
- ROL: rotate left through carry (A or memory)
- ROR: rotate right through carry (A or memory)

Branches (relative)

- BCC: branch if carry clear
- BCS: branch if carry set
- BEQ: branch if zero set
- BNE: branch if zero clear
- BPL: branch if negative clear
- BMI: branch if negative set
- BVC: branch if overflow clear
- BVS: branch if overflow set

Jumps and Calls

- JMP $addr or ($addr)
- JSR $addr
- RTS

Stack Instructions

- PHA: push A
- PLA: pull A
- PHP: push processor status
- PLP: pull processor status
- TSX: SP → X
- TXS: X → SP

Flags

- CLC: clear carry
- SEC: set carry
- CLD: clear decimal
- SED: set decimal
- CLI: clear interrupt
- SEI: set interrupt
- CLV: clear overflow

NOP: does nothing

Hardware Quirks (turned off unless you want it)

- JMP ($xxFF) wraps high byte incorrectly
- Decimal mode may fail on some chips

Assembler-Specific Features

- Reserve memory: .res NAME VALUE → allocates 1 byte at free memory
- Set origin: .org $ADDR → sets PC
- Vectors: .onStart LABEL, .onNMI LABEL, .onIRQ LABEL
- Labels: NAME: defines label at current PC
- Comments: ; starts comment


Vectors
- they are some points in memory that are ran when something happens, there are 3
    - .onStart label to goto on start
    - .onNMI   mostly unused in real 6502s but in the emulators this is the interrupt for new character
    - .onIRQ   not used at all, is triggred on BRK or out side interrupt


Examples:

Printing Hello, world

    .org $0200

    START:
        LDA #$48; h
        JSR PRINT_CHAR

        LDA #$65; e
        JSR PRINT_CHAR

        LDA #$6C; l
        JSR PRINT_CHAR

        LDA #$6C; l
        JSR PRINT_CHAR

        LDA #$6F; o
        JSR PRINT_CHAR

        LDA #$2C; ,
        JSR PRINT_CHAR

        LDA #$20; 
        JSR PRINT_CHAR

        LDA #$77; w
        JSR PRINT_CHAR

        LDA #$6F; o
        JSR PRINT_CHAR

        LDA #$72; r
        JSR PRINT_CHAR

        LDA #$6C; l
        JSR PRINT_CHAR

        LDA #$64; d
        JSR PRINT_CHAR

        JMP END

    ; print the char in reg A
    PRINT_CHAR:
        STA $FFF8
        LDA #$01
        STA $FFF9
        RTS

    END:
    JMP END

    NMI:
    IRQ:
    JMP START

    .onStart START
    .onNMI NMI
    .onIRQ IRQ



Input Test

    JMP AWAIT

    ; attatched to NMI and emulators input mecanism
    ON_CHAR:
        LDA $FFF6
        JSR PRINT_CHAR
        JMP AWAIT

    ; print the char in reg A
    PRINT_CHAR:
        STA $FFF8
        LDA #$01
        STA $FFF9
        RTS

    AWAIT:
    JMP AWAIT

    .onStart AWAIT
    .onNMI ON_CHAR
    .onIRQ AWAIT